--- nano-2.6.2/config.h.in.0002~	2016-07-28 09:26:07.000000000 +0200
+++ nano-2.6.2/config.h.in	2016-07-28 16:35:36.786450058 +0200
@@ -72,6 +72,9 @@
 /* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
 #undef HAVE_DOPRNT
 
+/* Define to 1 if you have the `futimens' function. */
+#undef HAVE_FUTIMENS
+
 /* Define to 1 if you have the `getdelim' function. */
 #undef HAVE_GETDELIM
 
--- nano-2.6.2/configure.0002~	2016-07-28 09:25:37.000000000 +0200
+++ nano-2.6.2/configure	2016-07-28 16:35:36.788450051 +0200
@@ -7776,7 +7776,7 @@ fi
 
 
 
-for ac_func in getdelim getline isblank strcasecmp strcasestr strncasecmp strnlen snprintf vsnprintf
+for ac_func in futimens getdelim getline isblank strcasecmp strcasestr strncasecmp strnlen snprintf vsnprintf
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
--- nano-2.6.2/configure.ac.0002~	2016-07-28 09:15:46.000000000 +0200
+++ nano-2.6.2/configure.ac	2016-07-28 16:35:36.788450051 +0200
@@ -442,7 +442,7 @@ int main(void)
 
 dnl Checks for functions.
 
-AC_CHECK_FUNCS(getdelim getline isblank strcasecmp strcasestr strncasecmp strnlen snprintf vsnprintf)
+AC_CHECK_FUNCS(futimens getdelim getline isblank strcasecmp strcasestr strncasecmp strnlen snprintf vsnprintf)
 
 if test "x$enable_utf8" != xno; then
     AC_CHECK_FUNCS(iswalnum iswblank iswpunct iswspace nl_langinfo mblen mbstowcs mbtowc wctomb wcwidth)
--- nano-2.6.2/src/files.c.0002~	2016-07-27 21:45:10.000000000 +0200
+++ nano-2.6.2/src/files.c	2016-07-28 16:36:49.268208367 +0200
@@ -1687,6 +1687,29 @@ int copy_file(FILE *inn, FILE *out)
     return retval;
 }
 
+#ifdef HAVE_FUTIMENS
+/* set atime/mtime by file descriptor */
+int utime_wrap(int fd, const char *filename, struct utimbuf *ut)
+{
+    struct timespec times[2];
+    (void) filename;
+
+    times[0].tv_sec = ut->actime;
+    times[1].tv_sec = ut->modtime;
+    times[0].tv_nsec = 0L;
+    times[1].tv_nsec = 0L;
+
+    return futimens(fd, times);
+}
+#else
+/* set atime/mtime by file name */
+int utime_wrap(int fd, const char *filename, struct utimbuf *ut)
+{
+    (void) fd;
+    return utime(filename, ut);
+}
+#endif
+
 /* Write a file out to disk.  If f_open isn't NULL, we assume that it is
  * a stream associated with the file, and we don't try to open it
  * ourselves.  If tmp is TRUE, we set the umask to disallow anyone else
@@ -1908,17 +1931,9 @@ bool write_file(const char *name, FILE *
 	fprintf(stderr, "Backing up %s to %s\n", realname, backupname);
 #endif
 
-	/* Copy the file. */
-	copy_status = copy_file(f, backup_file);
-
-	if (copy_status != 0) {
-	    statusline(ALERT, _("Error reading %s: %s"), realname,
-			strerror(errno));
-	    goto cleanup_and_exit;
-	}
-
-	/* And set its metadata. */
-	if (utime(backupname, &filetime) == -1 && !ISSET(INSECURE_BACKUP)) {
+	/* Set backup's file metadata. */
+	if (utime_wrap(backup_fd, backupname, &filetime) == -1
+	               && !ISSET(INSECURE_BACKUP)) {
 	    if (prompt_failed_backupwrite(backupname))
 		goto skip_backup;
 	    statusline(HUSH, _("Error writing backup file %s: %s"),
@@ -1930,6 +1945,17 @@ bool write_file(const char *name, FILE *
 	    goto cleanup_and_exit;
 	}
 
+	/* Copy the file. */
+	copy_status = copy_file(f, backup_file);
+
+	if (copy_status != 0) {
+           char msg[512];
+           snprintf(msg, 512, _("Error reading %s: %s"), realname, strerror(errno));
+	    statusbar(msg);
+	    beep();
+	    goto cleanup_and_exit;
+	}
+
 	free(backupname);
     }
 
